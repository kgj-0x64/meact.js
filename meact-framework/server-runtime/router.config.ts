import { promises as fs, writeFileSync } from "fs";
import * as path from "path";
import {
  MEACT_FRAMEWORK_SERVER_DIRECTORY,
  SERVER_API_DIRECTORY,
} from "../constants/namingConventions";

async function getFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });

  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? getFiles(res) : res;
    })
  );

  // flatten the array
  return files.flat();
}

async function handleRouterScriptFiles(scriptFiles: string[]) {
  const imports: string[] = [];
  const mapEntries: string[] = [];

  const outputFile = path.resolve(MEACT_FRAMEWORK_SERVER_DIRECTORY, "build.js");

  for (const scriptFile of scriptFiles) {
    // get the relative path from one absolute path to the other absolute path
    const relativePath = path.relative(path.dirname(outputFile), scriptFile);

    // `relativePath` uses backslashes (\\), which are specific to Windows.
    // Forward slashes work on all platforms, including Windows, Linux, and macOS.
    const importPath = relativePath.replace(/\\/g, "/");

    const fileName = scriptFile.endsWith(".js")
      ? path.basename(scriptFile, ".js")
      : path.basename(scriptFile, ".ts");

    const importStatementForThisFile = `import * as ${fileName} from "${importPath}";`;
    imports.push(importStatementForThisFile);

    // Dynamically import the module
    const fileModule = await import(importPath);

    let isThisPageRoute = false;

    // sanity check
    if (!("componentName" in fileModule)) {
      throw new Error(
        `server/api/${fileName} is missing export of "componentName" value`
      );
    } else {
      isThisPageRoute =
        fileModule["componentName"] &&
        fileModule["componentName"].endsWith("Page");
    }

    const mapKey = fileName.startsWith("_")
      ? `${fileName}.componentName`
      : `"${fileName}"`;

    const fileModuleExports = ["componentName", "meta", "loader", "action"]
      .filter((name) => name in fileModule)
      .map((exportedName) => `${exportedName}: ${fileName}.${exportedName},`);

    const mapEntry = `[
      ${mapKey},
      {
        isPage: ${isThisPageRoute},
        ${fileModuleExports.join("\n")}
      },
    ],`;

    mapEntries.push(mapEntry);
  }

  const outputContent = `
    /**
      * 
      * ! DON'T EDIT Directly!!!
      * Generated by running framework.build.ts
      *  
    */
    ${imports.join("\n")}

    export const mapOfComponentNameToServerSideHandlers = new Map([
      ${mapEntries.join("\n")}
    ]);
  `;

  // takes path relative to the root directory
  writeFileSync(
    path.join(MEACT_FRAMEWORK_SERVER_DIRECTORY, "build.js"),
    outputContent.trim()
  );
}

async function buildMeactFrameworkServerSideHandlersMap() {
  console.log("Meact app's server side handlers have to be registered...");

  const apiDir = SERVER_API_DIRECTORY;

  const files = await getFiles(apiDir);

  const scriptFiles = files.filter(
    (file) => file.endsWith(".ts") || file.endsWith(".js")
  );

  await handleRouterScriptFiles(scriptFiles);

  console.log(
    "Meact app's server side handlers have been registered successfully."
  );
}

buildMeactFrameworkServerSideHandlersMap()
  .then(() => {
    console.log("Successfuly built Meact app's server-side handlers map");
    process.exit(); // Explicitly terminate the process
  })
  .catch((err) => {
    console.error(
      "Error in building Meact app's server-side handlers map:",
      err
    );
    process.exit(1); // Exit with a non-zero status code on error
  });
